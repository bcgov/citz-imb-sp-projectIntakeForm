"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var node_sp_auth_config_1 = require("node-sp-auth-config");
var express = require("express");
var bodyParser = require("body-parser");
var cors = require("cors");
var path = require("path");
var fs = require("fs");
var https = require("https");
var logger_1 = require("../utils/logger");
var restGet_1 = require("./routers/restGet");
var restPost_1 = require("./routers/restPost");
var restBatch_1 = require("./routers/restBatch");
var csom_1 = require("./routers/csom");
var soap_1 = require("./routers/soap");
var genericPost_1 = require("./routers/genericPost");
var genericGet_1 = require("./routers/genericGet");
var server_1 = require("../gateway/server");
var client_1 = require("../gateway/client");
var RestProxy = (function () {
    function RestProxy(settings, app) {
        var _this = this;
        if (settings === void 0) { settings = {}; }
        this.isExtApp = false;
        this.serveGateway = function (settings) {
            new server_1.Server(settings, _this.settings, _this.app).init();
        };
        this.serveClient = function (settings) {
            new client_1.Client(settings, _this.settings).init();
            _this.serve();
        };
        var authConfigSettings = settings.authConfigSettings || {};
        this.settings = __assign(__assign({}, settings), { protocol: typeof settings.protocol !== 'undefined' ? settings.protocol : 'http', hostname: settings.hostname || process.env.HOSTNAME || 'localhost', port: settings.port || process.env.PORT || 8080, staticRoot: path.resolve(settings.staticRoot || path.join(__dirname, '/../../static')), rawBodyLimitSize: settings.rawBodyLimitSize || '10MB', jsonPayloadLimitSize: settings.jsonPayloadLimitSize || '2MB', metadata: require(path.join(__dirname, '/../../package.json')), strictRelativeUrls: typeof settings.strictRelativeUrls !== 'undefined' ? settings.strictRelativeUrls : false, agent: settings.agent || new https.Agent({
                rejectUnauthorized: false,
                keepAlive: true,
                keepAliveMsecs: 10000
            }), authConfigSettings: __assign(__assign({}, authConfigSettings), { configPath: path.resolve(authConfigSettings.configPath || settings.configPath || './config/private.json'), defaultConfigPath: authConfigSettings.defaultConfigPath || settings.defaultConfigPath, encryptPassword: typeof authConfigSettings.encryptPassword !== 'undefined' ? authConfigSettings.encryptPassword : true, saveConfigOnDisk: typeof authConfigSettings.saveConfigOnDisk !== 'undefined' ? authConfigSettings.saveConfigOnDisk : true }) });
        this.logger = new logger_1.Logger(this.settings.logLevel);
        if (typeof app !== 'undefined') {
            this.app = app;
            this.isExtApp = true;
        }
        else {
            this.app = express();
        }
        this.routers = {
            apiRestRouter: express.Router(),
            apiCsomRouter: express.Router(),
            apiSoapRouter: express.Router(),
            genericPostRouter: express.Router(),
            genericGetRouter: express.Router()
        };
    }
    RestProxy.prototype.serveProxy = function (callback) {
        this.serve(callback);
    };
    RestProxy.prototype.serve = function (callback, errorCallback) {
        var _this = this;
        (function () { return __awaiter(_this, void 0, void 0, function () {
            var ctx, context, bodyParserRaw, bodyParserUrlencoded, upCallback, server, options;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, new node_sp_auth_config_1.AuthConfig(this.settings.authConfigSettings).getContext()];
                    case 1:
                        ctx = _a.sent();
                        context = __assign(__assign({}, ctx), { proxyHostUrl: this.settings.protocol + "://" + this.settings.hostname + ":" + this.settings.port });
                        bodyParserRaw = bodyParser.raw({
                            type: function () { return true; },
                            limit: this.settings.rawBodyLimitSize,
                            verify: function (req, _res, buf, encoding) {
                                if (buf && buf.length) {
                                    req.rawBody = buf.toString(encoding || 'utf8');
                                    req.buffer = buf;
                                }
                            }
                        });
                        bodyParserUrlencoded = bodyParser.urlencoded({ extended: true });
                        this.routers.apiRestRouter.post("/*(" + [
                            '/attachmentfiles/add',
                            '/files/add',
                            '/startUpload',
                            '/continueUpload',
                            '/finishUpload',
                            '/_layouts/15/Upload'
                        ].join('|') + ")*", bodyParserRaw, new restPost_1.RestPostRouter(context, this.settings).router);
                        this.routers.apiRestRouter.post('/[$]batch', bodyParserRaw, new restBatch_1.RestBatchRouter(context, this.settings).router);
                        this.routers.apiRestRouter.get('/*', new restGet_1.RestGetRouter(context, this.settings).router);
                        this.routers.apiRestRouter.post('/*', bodyParser.json({
                            limit: this.settings.jsonPayloadLimitSize
                        }), new restPost_1.RestPostRouter(context, this.settings).router);
                        (function () {
                            _this.routers.apiRestRouter.put('/*', bodyParser.json({
                                limit: _this.settings.jsonPayloadLimitSize
                            }), new restPost_1.RestPostRouter(context, _this.settings).router);
                            _this.routers.apiRestRouter.patch('/*', bodyParser.json({
                                limit: _this.settings.jsonPayloadLimitSize
                            }), new restPost_1.RestPostRouter(context, _this.settings).router);
                        })();
                        this.routers.apiCsomRouter.post('/*', bodyParserUrlencoded, new csom_1.CsomRouter(context, this.settings).router);
                        this.routers.apiSoapRouter.post('/*', bodyParserUrlencoded, new soap_1.SoapRouter(context, this.settings).router);
                        this.routers.genericGetRouter.get('/*', new genericGet_1.GetRouter(context, this.settings).router);
                        this.routers.genericPostRouter.post('/*', bodyParserUrlencoded, new genericPost_1.PostRouter(context, this.settings).router);
                        this.app.use(cors());
                        this.app.use('*/_api', this.routers.apiRestRouter);
                        this.app.use('*/_vti_bin/client.svc/ProcessQuery', this.routers.apiCsomRouter);
                        this.app.use('*/_vti_bin/*.asmx', this.routers.apiSoapRouter);
                        this.app.use('*/_vti_bin/ListData.svc', this.routers.genericPostRouter);
                        this.app.use('*/_vti_bin/ListData.svc', this.routers.genericGetRouter);
                        this.app.use('/', this.routers.genericPostRouter);
                        this.app.use('/', this.routers.genericGetRouter);
                        if (this.isExtApp) {
                            return [2];
                        }
                        upCallback = function (s, cx, settings, cb) {
                            _this.logger.info("SharePoint REST Proxy has been started on " + cx.proxyHostUrl);
                            if (cb && typeof cb === 'function') {
                                cb(s, cx, settings);
                            }
                        };
                        server = null;
                        if (this.settings.protocol === 'https') {
                            if (typeof this.settings.ssl === 'undefined') {
                                this.settings.ssl = {
                                    cert: path.join(__dirname, './../../ssl/cert.crt'),
                                    key: path.join(__dirname, './../../ssl/key.pem')
                                };
                            }
                            options = {
                                cert: fs.existsSync(this.settings.ssl.cert) ? fs.readFileSync(this.settings.ssl.cert) : this.settings.ssl.cert,
                                key: fs.existsSync(this.settings.ssl.key) ? fs.readFileSync(this.settings.ssl.key) : this.settings.ssl.key
                            };
                            server = https.createServer(options, this.app);
                        }
                        else {
                            server = require('http').Server(this.app);
                        }
                        if (server) {
                            server.listen(this.settings.port, this.settings.hostname, function () {
                                upCallback(server, context, _this.settings, callback);
                            });
                        }
                        return [2];
                }
            });
        }); })().catch(function (error) {
            _this.logger.error(error);
            if (errorCallback) {
                errorCallback(error);
            }
        });
    };
    return RestProxy;
}());
exports.default = RestProxy;
//# sourceMappingURL=RestProxy.js.map